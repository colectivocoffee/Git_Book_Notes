# \[Medium\] Combinations/Permutations/Subsets

### [\[Medium\] Combinations](https://leetcode.com/problems/combinations/)

\(1703/70\)  
Given two integers _n_ and _k_, return all possible combinations of _k_ numbers out of 1 ... _n_.  
You may return the answer in **any order**.

> 思路：用DFS Recursive遍歷所有可能的組合。

```python
def combine(self, n: int, k: int) -> List[List[int]]:
    result = []
    # possible nums generated by n
    nums = [i for i in range(1, n+1)] #從1開始
    self.dfs(nums, k, result, 0, [])
    return result

# Recursive DFS
def dfs(self, nums, k, result, curr_id, curr_res):
    # 遞歸出口
    if k == 0:
        result.append(curr_res)
        return
        
    for i in range(curr_id, len(nums)): #易錯點 curr_id -> len(nums)
        self.dfs(nums, k-1, result, i+1, curr_res + [nums[i]])
```

### \[Medium\] Combination Sum

```python
def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
    result = []
    self.dfs(candidates, target, result, 0, [])
    return result

def dfs(self, nums, target, result, curr_id, curr_res):
    # 遞歸出口
    if target == 0:
        result.append(curr_res)
        return
    # check boundary
    if target < 0:
        return 
    for i in range(curr_id, len(nums)):
        # 易錯點： use curr_id = i since we allow duplicates
        self.dfs(nums, target - i, result, i, curr_res + [nums[i]])
```

### \[Medium\] Combination Sum II

Given a collection of candidate numbers \(`candidates`\) and a target number \(`target`\), find all unique combinations in `candidates` where the candidate numbers sums to `target`.  
Each number in `candidates` may only be used **once** in the combination.  
Note:

* All numbers \(including `target`\) will be positive integers.
* The solution set must not contain duplicate combinations.

> 思路：和Combination Sum的DFS Recursive處理方法相同。  
> 但需要注意以下幾點：  
> \(1\) Skip Duplicates: 用 `i > curr_id and nums[i] == nums[i-1]`來判斷重複數  
> \(2\) 更新curr\_id時: 用`curr_id = i + 1`

```python
def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
    result = []
    self.dfs(candidates, target, result, 0, [])
    return result

def dfs(self, nums, target, result, curr_id, curr_result):
    # 遞歸出口
    if target == 0:
        result.append(curr_result)
        return
    # out of boundary
    if target < 0:
        return
    for i in range(curr_id, len(nums)): 
        # Critical Step to REMOVE DUPLICATES
        # 我們不使用 i > 0 是因為，不想算first element即使它是和上一個值一樣的數。
        # 如果要避免重複計算，我們用continue來跳過所有"第一個之後"的重複數。
        # ex: [1,1,1,2]  => [1a,1b,1c,2]
        # then skip 1b,1c 
        if i > curr_id and nums[i] == nums[i-1]:
            continue
        # To Optimize
        if nums[i] > target:
            break
        # use curr_id = i + 1 because one element can only be used once
        self.dfs(nums, target - nums[i], result, i + 1, curr_result + [nums[i]])
        
```

```python
def permute(self, nums: List[int]) -> List[List[int]]:
```

### \[Medium\] Permutations



```python

```

