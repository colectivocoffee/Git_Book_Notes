# \[Medium\] Subsets/Combinations/Permutations/Combinations on Phone

### [\[Medium\] Subsets](https://leetcode.com/problems/subsets/)

Given a set of **distinct** integers, _nums_, return all possible subsets \(the power set\).  
Note: The solution set must not contain duplicate subsets.

此題有三種解法：\(1\)BacktrackingDFS \(2\) BFS \(3\) Bit Manipulation

```python
def subsets(self, nums: List[int]) -> List[List[int]]:
    result = []
    nums.sort()                            # 需要先sort去重
    self.dfs(nums, result, 0, [])
    return result
# Backtracking DFS
'''
nums:    給定的nums list
result:  最終結果
curr_id: 下次添加到結果集合的元素位置index
curr_result: 臨時結果集合
'''
def dfs(self, nums, result, curr_id, curr_result):
    # 遞歸出口
    result.append(curr_result)             # 不用判斷，直接把路徑加到result
    # 選擇 - 處理結果 - 再撤銷選擇
    for i in range(curr_id, len(nums)):    # curr_id -> len(nums)
        self.dfs(nums, result, i + 1, curr_result + [nums[i]])
```

### [\[Medium\] Subsets II](https://leetcode.com/problems/subsets-ii/)

\(1866/83\)  
Given a collection of integers that might contain duplicates, _**nums**_, return all possible subsets \(the power set\).  
Note: The solution set must not contain duplicate subsets.

```python
def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
    result = []
    nums.sort()
    self.dfs(nums, result, 0, [])
    return result
# Backtracking DFS
def dfs(self, nums, result, curr_id, curr_result):
    # 遞歸出口
    result.append(curr_result)
    # 選擇時需要剪枝、處理、撤銷選擇
    for i in range(curr_id, len(nums)):
        
        if i > curr_id and nums[i] == nums[i-1]:  # i > curr_id，需要判斷Duplicates
            continue
        self.dfs(nums, result, i + 1, curr_result + [nums[i]])
                
```

### [\[Medium\] Combinations](https://leetcode.com/problems/combinations/)

\(1703/70\)  
Given two integers _n_ and _k_, return all possible combinations of _k_ numbers out of 1 ... _n_.  
You may return the answer in **any order**.

> 思路：用DFS Recursive遍歷所有可能的組合。

```python
def combine(self, n: int, k: int) -> List[List[int]]:
    result = []
    # possible nums generated by n
    nums = [i for i in range(1, n+1)] #從1開始
    self.dfs(nums, k, result, 0, [])
    return result

# Backtracking DFS 
def dfs(self, nums, k, result, curr_id, curr_res):
    # 遞歸出口
    if k == 0:
        result.append(curr_res)
        return
        
    for i in range(curr_id, len(nums)): #易錯點 curr_id -> len(nums)
        self.dfs(nums, k-1, result, i+1, curr_res + [nums[i]])
```

### [\[Medium\] Combination Sum](https://leetcode.com/problems/combination-sum/)

```python
def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
    result = []
    self.dfs(candidates, target, result, 0, [])
    return result

def dfs(self, nums, target, result, curr_id, curr_res):
    # 遞歸出口
    if target == 0:
        result.append(curr_res)
        return
    # check boundary
    if target < 0:
        return 
    for i in range(curr_id, len(nums)):
        # 易錯點： use curr_id = i since we allow duplicates
        self.dfs(nums, target - i, result, i, curr_res + [nums[i]])
```

### [\[Medium\] Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)

Given a collection of candidate numbers \(`candidates`\) and a target number \(`target`\), find all unique combinations in `candidates` where the candidate numbers sums to `target`.  
Each number in `candidates` may only be used **once** in the combination.  
Note:

* All numbers \(including `target`\) will be positive integers.
* The solution set must not contain duplicate combinations.

> 思路：和Combination Sum的DFS Recursive處理方法相同。  
> 但需要注意以下幾點：  
> \(1\) Skip Duplicates: 用 `i > curr_id and nums[i] == nums[i-1]`來判斷重複數  
> \(2\) 更新curr\_id時: 用`curr_id = i + 1`

```python
def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
    result = []
    self.dfs(candidates, target, result, 0, [])
    return result

def dfs(self, nums, target, result, curr_id, curr_result):
    # 遞歸出口
    if target == 0:
        result.append(curr_result)
        return
    # out of boundary
    if target < 0:
        return
    for i in range(curr_id, len(nums)): 
        # Critical Step to REMOVE DUPLICATES
        # 我們不使用 i > 0 是因為，不想算first element即使它是和上一個值一樣的數。
        # 如果要避免重複計算，我們用continue來跳過所有"第一個之後"的重複數。
        # ex: [1,1,1,2]  => [1a,1b,1c,2]
        # then skip 1b,1c 
        if i > curr_id and nums[i] == nums[i-1]:
            continue
        # To Optimize
        if nums[i] > target:
            break
        # use curr_id = i + 1 because one element can only be used once
        self.dfs(nums, target - nums[i], result, i + 1, curr_result + [nums[i]])
        
```

### [\[Medium\] Permutations](https://leetcode.com/problems/permutations/)

\(4459/112\)  
Given a collection of **distinct** integers, return all possible permutations.

> 思路：

```python
def permute(self, nums: List[int]) -> List[List[int]]:
    result = []
    self.dfs(nums, result, [])
    return result

def dfs(self, nums, result, curr_result):
    # 易錯點：
    # 判斷條件是 not nums，因為每一次在遞歸的時候，都少掉一個nums[i]
    # 下面用nums[:i] + nums[i+1:]來拿出nums[i]
    if not nums:
        result.append(curr_result)
        return
        
    for i in range(len(nums)):
        # 這裡用nums[:i] + nums[i+1:] 來省略nums[i]
        self.dfs(nums[:i] + nums[i+1:], result, i, curr_result + [nums[i]])
        
```

### [\[Medium\] Permutations II](https://leetcode.com/problems/permutations-ii/)

Given a collection of numbers that might contain duplicates, return all possible unique permutations.

> 思路：

```python
def permuteUnique(self, nums: List[int]) -> List[List[int]]:
    result = []
    # To put all same numbers together
    nums.sort()                        # 要先sort，才能去重複計算。
    self.dfs(nums, result, [])
    return result

def dfs(self, nums, result, curr_result):
    
    if not nums:
        result.append(curr_result)
        return
    
    for i in range(len(nums)):
        # 和combination sum比較差異
        # [1,2,1] -> [1a,1b,2]
        # 又此判斷句要和nums.sort()合併用，由於sort後，把所有的相同數字放在一起，
        # 因此如果有相同數字，即代表duplicates
        if i > 0 and nums[i] == nums[i-1]:  # 用i > 0
            continue
        self.dfs(nums[:i] + nums[i+1:], result, curr_result + [nums[i]])
```

### \[Medium\] Letter Combinations of a Phone Number

Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent.  
A mapping of digit to letters \(just like on the telephone buttons\) is given below. Note that 1 does not map to any letters.  
  
phone keyboard = { '2': 'abc', '3': 'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}

```python
KEYBOARD = { '2': 'abc', '3': 'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}

def letterCombinations(self, digits: str) -> List[str]:
    
    result = []
    if not digits:
        return result
    
    self.dfs(digits, result, 0, '')
    return result
    
def dfs(self, nums, result, curr_id, curr_res):
    
    if curr_id >= len(nums):       #易錯點：>= 否則會out of range
        result.append(curr_res)
        return
    
    for i in KEYBOARD[nums[curr_id]]:
        self.dfs(nums, result, curr_id + 1, curr_res + i)
```

